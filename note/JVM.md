Java与C++之间有一堵由==内存动态分配==和==垃圾收集技术==所围成的高墙。

# 内存结构

![](https://gitee.com/DtreeL/Image-Hosting-Service/raw/master/img/20200509134402.png)

![](https://gitee.com/DtreeL/Image-Hosting-Service/raw/master/img/20200521193112.png)

程序计数器（线程私有）

- 当前线程所执行的字节码的行号指示器，字节码解释器通过改变计数器的值选择下一条需要执行的字节码指令

- 每条线程都需要有一个独立的程序计数器，称这类内存区域为“线程私有”的内存
- **执行的是一个Java方法，记录的是正在执行的虚拟机字节码指令的地址；执行的是本地（Native）方法，计数器值为空（Undefined）**

java虚拟机栈（线程私有）

- 生命周期与线程相同
- ==虚拟机栈描述的是Java方法执行的线程内存模型==：每个方法被执行的时候，Java虚拟机都
  会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信
  息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
- “栈”通常就是指这里讲的虚拟机栈,或者更多的情况下只是指==虚拟机栈中局部变量表==部分。
  - 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用和returnAddress
    类型（指向了一条字节码指令的地址）
  - 这些==数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示==，其中64位长度的long和
    double类型的数据会占用两个变量槽，其余的数据类型只占用一个
  - ==局部变量表所需的内存空间在编译期间完成分配==，当进入一个方法时，==这个方法需要在栈帧中分配多大的局部变量空间是完全确定的==，在方法==运行期间不会改变局部变量表的大小==。

java堆

- 所有线程**共享**的一块内存区域，==唯一目的就是存放对象实例==
- 垃圾收集器管理的内存区域
- 当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）

方法区

- 各个**线程共享**的内存区域
- ==存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据==
- 运行时常量池
  - Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（这部分内容将在类加载后存放到方法区的运行时常量池中）
  - ==运行期间也可以将新的常量放入池中==，String类的intern()方法

直接内存（不是虚拟机运行时数据区的一部分）

- NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式
- ==使用Native函数库直接分配堆外内存==，然后==通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作==。避免了在Java堆和Native堆中来回复制数据

# 类加载机制

![](https://gitee.com/DtreeL/Image-Hosting-Service/raw/master/img/20200521193330.png)

类加载器将这些.class文件加载到JVM中。其中**类装载器**的**作用**其实就是类的加载。

> 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。

JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误

从哪加载？

（1）本地磁盘

（2）网上加载.class文件（Applet）

（3）从数据库中

（4）压缩文件中（ZAR，jar等）

（5）从其他文件生成的（JSP应用）

## 过程

**类加载的过程包括了加载、验证、准备、解析、初始化五个阶段**。然后就可以使用了

- 加载、验证、准备和初始化这四个阶段发生的顺序是确定的，是按顺序**开始**，而不是按顺序**进行**或**完成**，互相交叉地混合进行的

- 解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始

### 加载

（1）通过一个类的全限定名来获取其定义的二进制字节流

（2）将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构

（3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。

### 验证

确保被加载的类的正确性，加载好的.class文件不能对我们的虚拟机有危害

（1）文件格式的验证，主要对魔数、主版本号、常量池等等的校验

（2）元数据验证：主要是对字节码描述的信息进行语义分析，符合Java语言规范

（3）字节码验证：确定程序语义是合法的、符合逻辑的。

（4）符号引用验证：是对类自身以外的信息进行校验

### 准备

**为类变量分配内存并设置初始值**，这些内存都在方法区分配

这里的**初始值指的是数据类型默认值，而不是代码中被显示赋予的值**

### 解析

将常量池中的符号引用转化为直接引用的过程

### 初始化

只有当对类的主动使用的时候才会导致类的初始化

- new
- 访问静态变量或为静态变量赋值时
- 调用静态方法
- 反射
- 初始化子类会先初始化父类
- 启动表明为启动类的类

## 类加载器

Bootstrap ClassLoader ：最顶层的加载类，主要加载核心类库

- 环境变量下面%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。

Extention ClassLoader  ：扩展的类加载器

- 加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件

Appclass Loader：也称为SystemAppClass。 加载当前应用的classpath的所有类。

**Bootstrap ClassLoader  >  Extention ClassLoader  >  Appclass Loader**

- Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。

---

**类加载的三种方式**

- 启动时由JVM初始化加载含有main()方法的主类

- 通过Class.forName()方法动态加载，会默认执行初始化块（static{}），但是

  Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。

- 通过ClassLoader.loadClass()方法动态加载，不会执行初始化块

## 双亲委派原则

当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。

1. 可以避免重复加载，父类已经加载了，子类就不需要再次加载
2. 更加安全，很好的解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患

# 垃圾回收机制

类加载过程中最后一个阶段：卸载

线程独有的随线程而生，随线程而灭，方法结束或者线程结束，内存自然就跟随着回收了。

## 内存垃圾回收算法

### 判断垃圾算法

**引用计数法**：为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当该个数为零可以认为“对象死亡”

- 无法检测“循环引用”：当两个对象互相引用，它俩的计数都不为零，因此永远不会被回收。
- 两个类相互是对方的成员变量，toString的时候，相互调用。造成循环引用。
- Java 里没有采用这样的方案来判定对象的“存活性”

---

可达性分析：把所有引用的对象想象成一棵树，从树的根结点 GC Roots 出发，持续遍历找出所有连接的树枝对象，这些对象则被称为“可达”对象，或称“存活”对象。不能到达的则被可回收对象。

初始点我们一定是可达的。那么，Java 里有哪些对象可以作为GC Roots呢？主要有以下四种：

- 虚拟机栈（帧栈中的本地变量表）中引用的对象。
- 方法区中静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中 JNI 引用的对象。

### 回收垃圾算法

**1、标记－清理**

第一步（标记），利用可达性遍历内存，把“存活”对象和“垃圾”对象进行标记。第二步（清理），我们再遍历一遍，把所有“垃圾”对象所占的空间直接 清空 即可。

- 简单方便
- 容易产生内存碎片（不一定垃圾都是连续的一片，会出现内存有的地方清理被空出来，有的没被空出来，坑坑洼洼）

**2、标记－整理**

第一步（标记）：利用可达性遍历内存，把“存活”对象和“垃圾”对象进行标记。

第二步（整理）：把所有存活对象堆到同一个地方，这样就没有内存碎片了。

- 适合存活对象多，垃圾少的情况
- 需要整理的过程

**3、复制**

将内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完了，就将还活着的对象复制到另一块上，然后再把使用过的内存空间一次性清理掉

- 简单
- 不会产生碎片
- 内存利用率太低，只用了一半

## 堆和方法区的垃圾回收

Java中的垃圾回收大致在两部分，第一个就是堆、第二个就是方法区

### 方法区的垃圾回收

方法区又叫做永久代。

永久代的垃圾回收主要有两部分：废弃常量和无用的类。

---

第一步：判定一个常量是否是废弃常量：没有任何一个地方对这个常量进行引用就表示是废弃常量。

第二步：垃圾回收

---

第一步：判定一个类是否是“无用的类”：需要满足下面三个条件

- Java堆中**不存在该类的任何实例**，也就是该类的所有实例都被回收
- **加载该类的ClassLoader已经被回收**
- 该类对应的Class对象在任何地方**没有引用了，也不能通过反射访问该类的方法。**

第二步：满足上面三个条件就可以**回收**了，但不是强制的。

《java虚拟机规范》里面曾经说到过，**不要求虚拟机对方法区进行垃圾回收。而且方法区进行垃圾回收性价比比较低。**

### 堆的回收

![](https://gitee.com/DtreeL/Image-Hosting-Service/raw/master/img/20200521201118.png)

- 刚刚创建的对象。
- 存活了一段时间的对象。
- 永久存在的对象。

---

- 新生代：存活对象少、垃圾多
- 老年代：存活对象多、垃圾少

---

(**1)新生代－复制回收机制**

Eden：S1：S2=8:1:1

 Eden 意为伊甸园，形容有很多新生对象在里面创建；S1和S2中的S表示Survivor，为幸存者，即经历 GC 后仍然存活下来的对象。

1. 首先，Eden对外提供堆内存。当 Eden区快要满了，触发垃圾回收机制，把存活对象放入 Survivor A 区，清空 Eden 区；
2. Eden区被清空后，继续对外提供堆内存；
3. 当 Eden 区再次被填满，对 Eden区和 Survivor A 区同时进行垃圾回收，把存活对象放入 Survivor B区，同时清空 Eden 区和Survivor A 区；
4. 当某个 Survivor区被填满，把多余对象放到Old 区；
5. 当 Old 区也被填满时，进行 下一阶段的垃圾回收。

**（2）老年代－标记整理回收机制**

老年代的特点是：存活对象多、垃圾少。因此，根据老年代的特点，这里仅仅通过少量地移动对象就能清理垃圾，而且不存在内存碎片化。也就是标记整理的回收机制。既然是==标记整理算法==，而且老年代内部也不存在着内存划分，所以只需要根据标记整理的具体步骤进行垃圾回收就好了。

## 垃圾回收器

> 垃圾收集器就是内存回收的具体实现

吞吐量

- CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。比如说虚拟机总运行了 100 分钟，用户代码时间 `99` 分钟，**垃圾回收** 时间 1 分钟，那么吞吐量就是 99%。

停顿时间

- 垃圾回收器正在运行时，应用程序 的 暂停时间

**GC的名词**

- 新生代GC：Minor GC

- 老年代GC：Major GC

![](https://gitee.com/DtreeL/Image-Hosting-Service/raw/master/img/20200521201817.png)

# 性能监控工具

JDK安装目录会发现很多这样的exe文件

| jps（JVM Process Status Tool）          | 显示指定系统中所有的HotSpot虚拟机进程        |
| --------------------------------------- | -------------------------------------------- |
| jstat（JVM Statistics Monitoring Tool） | 收集HotSpot虚拟机各方面的运行数据            |
| jinfo（Configuration Info for Java）    | 显示虚拟机配置信息                           |
| jmap（Memory Map for Java）             | 生成虚拟机的内存转储快照（heapdump文件）     |
| jhat（JVM Heap Dump Browser）           | 分析内存转储快照，不推荐使用，消耗资源而且慢 |
| jstack（Stack Trace for Java）          | 显示虚拟机的线程快照                         |
| JConsole                                | JMX的可视化管理工具                          |
| VisualVM                                | 多合一故障管理工具                           |

# Java内存模型

Java内存模型也叫做JMM,但是这个模型可不是像java内存结构一样，是真实存在的。

java内存模型是一个抽象出来的概念。

- 把一部分内存区域设计成所有线程共享的，一个线程对数据更改，其他线程就能立刻知道。这种设计的方法叫做内存模型。

![](https://gitee.com/DtreeL/Image-Hosting-Service/raw/master/img/20200521202331.png)

**（1）java内存结构是解决java中的数据如何存放的问题。**

**（2）java内存模型是解决java中多个线程共享数据的问题。**

## 为什么有内存模型

阶段一

- CPU的速度越来越多高，但是主存的速度却没有提高太多

阶段二

- 解决上面的问题，于是乎出现了缓存，里面存放了一些CPU经常使用的主存数据，缓存的速度和CPU差不多，查找和写入都先对缓存进行操作

阶段三

- 出现了一级二级三级缓存，查找也是逐层的，第一级缓存没有就到第二层，就这样以此类推
- CPU也得到了快读发展，由之前的一个核变成了多核CPU
- 每一个核都有相应的缓存区，但是主内存还是那一个
  - 缓存一致性问题：线程2在写入前线程1读取数据到了缓存
  - 处理器优化和指令重排问题
    - CPU有这么多内核，肯定是想让资源得到充分利用，于是把我们写的程序拆分，对一些代码进行乱序处理，这就是处理器优化。
    - java虚拟机一看CPU的这个操作真的强，于是就模仿了一下，创建了即时编译器（JIT），这个编译器也会做**指令重排**的操作
  - 软件问题：缓存一致性问题带来原子性问题（CPU内核中同一变量数据不一样），可见性，有序性

---

阶段四

- 针对于这么多问题，于是Java虚拟机提出了一个java内存模型。有效地解决了上面出现的这三个问题：

规则一：所有的数据都在主内存中。

规则二：每个线程都保留一份共享变量的副本。线程对变量的所有操作都必须在这个副本内存中进行，而不能直接读写主内存。

规则三：不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

**synchronized关键字保证了原子性，volatile关键字保证了可见性。synchronized关键字和volatile关键字保证了有序性。当然还有很多的Lock机制，并发包里面等等都是为了解决这三个问题提出来的。**

## happens-before原则

> 为了解决可见性提出来的

如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。

（1）程序顺序规则：一个线程中的每个操作发生在后一个操作之前，这就是happens-before。

（2）锁规则：对于锁机制，一定要先加锁，才能解锁，这也是happens-before。

（3）volatile域规则：对一个volatile域的写操作一定要发生在读操作前面。

**必须要做饭，才能够吃到饭**

# Java中四种引用

强引用

- 即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。比如字符串引用

软引用

- 只有在内存空间不足时，软引用才会被垃圾回收器回收。这种引用常常被用来实现缓存技术。

弱引用

- 垃圾回收时候，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。

虚引用

- 相当于没有引用，在任何时候都有可能被回收。
- 可以通过它来观察对象是否已经被回收，从而进行相应的处理。

# 内存溢出问题

> 存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于虚拟机能提供的最大内存

（1）内存中加载的数据量过于庞大，如一次从数据库取出过多数据；

（2）集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；

（3）代码中存在死循环或循环产生过多重复的对象实体；

（4）使用的第三方软件中的BUG；

（5）启动参数内存值设定的过小；

**第一步**，修改JVM启动参数，直接增加内存。

**第二步**，检查错误日志

**第三步**，对代码进行走查和分析，找出可能发生内存溢出的位置。

# finalize方法对垃圾回收的影响

java虚拟机在进行垃圾回收的时候，一看到这个对象类含有finalize函数，就把这个函数交给FinalizerThread处理，而包含了这个finalize的对象就会被添加到FinalizerThread的执行队列，并使用一个链表，把这些包含了finalize的对象串起来。

影响在于只要finalize没有执行，那么这些对象就会一直存在堆区

执行完毕之后，将这个Finalizer对象从队列中移除，java虚拟机一看对象没有引用了，就进行垃圾回收了。

# 深堆和浅堆

（1）浅堆表示一个java对象结构所占用内存的大小，这个java对象内部包含了三部分数据：对象头、实例数据和对齐填充。

（2）深堆表示一个java对象被 GC 回收后，可以真实释放的内存大小。

---

一个对象分为三部分：对象头、实例数据、对齐填充。

**1、对象头**

- 标记部分：包括 hashcode、gc 分代年龄、锁状态标志、线程持有锁、偏向线程锁id，偏向时间戳。32位机器4 byte，64位机器8 byte
- 原始对象引用：对象的指针，通过这个指针找到对象的实例

**2、实例数据**：指的就是java对象实例。

**3、对齐填充**：java中的对象都是以8个字节为单位对齐，所以每一个java对象的大小都是8的整数倍。

---

保留集

- 对象A能直接或者是间接访问其他的对象，这些对象集合起来就是A的保留集。当进行垃圾回收的时候，不仅回收A，也会回收保留集中所有的对象。

**浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间**