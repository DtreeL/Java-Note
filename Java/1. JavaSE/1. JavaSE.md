# 基本概念

- JDK：Java Development Kit
- JRE：Java Runtime Environment（Java虚拟机，只提供运行字节码）

---

- Java SE：Standard Edition
- Java EE：Enterprise Edition
- Java ME：Micro Edition

Java SE就是标准版，包含标准的JVM和标准库

而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。

Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。

# 面向对象

>类是图纸，对象是根据图纸做出来实物
>
>因为Java是面向对象的语言，一个程序的基本单位就是`class`。

面向过程：跟步骤交互，第一步，第二步。。。

面向对象：跟对象交互，有了对象后，跟对象交互（调用方法），面向对象把过程的步骤封装在了方法中

---

类由**方法**和**字段**==两部分==组成，其中又有静态和实例之分

- ==方法==（**权限修饰符 [静态修饰符] [final] 返回值类型 方法名（参数列表）[throws]**）
  - 静态方法（static修饰。属于类，==没有对象也可以通过**类名.字段名**的形式访问==）
  - 实例方法（对象名.字段名形式）
- ==字段==（**权限修饰符 [静态修饰符] [final] 字段类型 字段名**）
  - 静态字段
  - 实例字段

**将功能（方法）、结构（属性）封装在类中，通过实例化来调用具体的功能和结构**

---

实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。

```ascii
        ┌──────────────────┐
ming ──>│Person instance   │
        ├──────────────────┤
        │name = "Xiao Ming"│
        │age = 12          │
        │number ───────────┼──┐    ┌─────────────┐
        └──────────────────┘  │    │Person class │
                              │    ├─────────────┤
                              ├───>│number = 99  │
        ┌──────────────────┐  │    └─────────────┘
hong ──>│Person instance   │  │
        ├──────────────────┤  │
        │name = "Xiao Hong"│  │
        │age = 15          │  │
        │number ───────────┼──┘
        └──────────────────┘
```

## 修饰符

### 权限修饰符

> 修饰方法和字段

private：只有**当前类**能直接访问，对象无法直接访问。除此之外修饰的，都是创建对象后能直接访问的

- 被修饰的方法，子类即使拥有相同的方法也不是覆写
- 被修饰的字段，子类无法访问

protected：同包类可以通过创建该类对象访问，不同包类只能通过创建该类的子类对象访问

- 被修饰的字段，子类可以访问

**默认**（无需写修饰符）：**同包**类创建出来的对象能访问

public：所有类创建出来的对象都能访问

### 其它修饰符

final：阻止作用。

- 阻止类被继承
- 阻止方法被覆写
- 阻止变量被第二次赋值

transient：修饰字段，被修饰的字段不会被序列化，而是默认值

static：被修饰的字段和方法所有该类创建的对象共享一份

## 方法

方法只在意输入什么，输出什么。和类中的字段不一定会有关联

### 构造方法

>顾名思义，构造方法是用来构造对象的，可以决定对象的出生属性值

- 类名与方法名相同的方法，无返回值（**返回值void是指返回空，而不是无返回值**）
  - 返回值代表整个方法的调用结果。返回值为void时，`return;`表示方法的结束

- 遇见new关键字自动调用，无需手动调用

### 方法重载

在一个类中，方法名相同，但是参数个数、类型、顺序不完全一致的方法。除了名字相同，方法是两个方法，不受被重载方法的限制

- 相同的功能，但是处理的东西不同
- 编译期就可确定

### 方法覆写

发生在子类中，覆写方法受父类的限制

- 访问修饰符不能更严格（当多态时，传入一个子类型则会出现无法访问该方法的情况），返回值类型不能更大，方法签名必须一致，可以不抛异常，如果抛异常不能抛范围更大的异常
- 无法覆写private修饰的方法

#### 继承

继承：**基于一个类创建一个类的技术**，继承一个类成为这个类家族的一员

- **继承一个类，就拥有这个类的所有字段和方法，复用了代码，只是私有字段和方法无法访问**
- 因为有些字段是从父类继承的，所以this.和super.的作用都是定位到父类的字段
- 子类***不会继承*任何父类的构造方法**。子类默认的构造方法是编译器自动生成的，不是继承的。

所有类都继承Object类，其中方法有

```java
.getClass();
.toString();
.hashCode();// 对象在堆中创建的一个特殊值，即便是同一个类创建的两个对象也不相等 
.equals();// ==判别，==判别引用是否是同一个对象，基本类型是判断值

.notify();
.notifyAll();
.wait();
```

#### hashCode与equals

> hasCode代表哈希表中的索引，当不涉及到哈希表时，两者无任何关系

HashMap等哈希表的数据结构中，键唯一，所以equals判别相等时，必定HashCode相等，所以需要覆写

### this与super

this：在方法内部，可以使用一个隐含的变量`this`，它始终指向当前实例。

- 因此，通过`this.field`就可以访问当前实例的字段。
- 没有命名冲突，可以省略`this`，有局部变量和字段重名，那么局部变量优先级更高，就必须加上`this`

super：父类的引用

- 可以调用父类的构造方法和父类被覆写的方法

## 多态

> 实现方式：继承和接口

程序中一个引用类型变量具体指向的类型以及这个变量调用的具体方法在编译期无法确定，只有在运行期才能确定

指向子类的父类引用或者指向实现类的接口引用，调用的**方法**是实际**真正类**的方法

- 上面说叫领导做事，但是领导没有真正做事，真正做事的是手下

## 抽象类和接口

抽象类：abstract修饰的类，可以有抽象方法也可以有其它方法，只要有抽象方法就是抽象类

- 抽象方法没有方法体，子类想要实例化必须覆写抽象方法
- 父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它
- **抽象类本身被设计成只能用于被继承，**因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。

接口：比抽象类更抽象。如果一个抽象类没有字段，所有方法全部都是抽象方法就可以把该抽象类改写为接口

- 方法默认public abstract修饰
- 1.8后可以有defalut默认实现，子类不必强制覆写
- 只能拥有static final修饰的字段

注意：抽象类跟接口一样无法实例化

# 类型

只有两种类型

1. 引用类型（类、数组、接口）

2. 基本类型

   ```java
   数值型
       整型：byte short int long
       浮点型：float double
   
   布尔型 boolean
   字符型 char
   ```

## 包装类

> 把基本类型封装成对象

```java
byte-->Byte
short-->Short
int-->Integer
long-->Long
    
float-->Float
double-->Double
    
boolean-->Boolean

char-->Character
```

- 整型包装类有缓存区：范围[-128,127]，这些范围的整型包装类是单例的；Character为[0,127]。只有Integer能改变缓存区范围

自动装箱：Integer.ValueOf-->return new Integer

自动拆箱：xxx.intValue-->return value;

# 核心类

## 字符串

String：维护一个final char[]类型字段用来存储字符串，所以是不可变的，不可变则只能读不能写-->线程安全

```java
// 先去常量池中寻找是否有，有则指向，无则创建再指向
String i = "123";

// 先去常量池中寻找是否有，有则在堆中创建相同的，指向堆中的。无则常量池中创建，再在堆中创建相同的，指向堆中的。
String i = new String(123);
```

”+“语法糖

- 采用new StringBulider，调用append方法，最后使用StringBulider的toString方法

String类的concat方法，实际是new了一个新的String类

----

StringBuffer、StringBulider

- 共同继承AbstractString：使用char[]维护，所以可变
- StringBuffer操作方法大都用synchronized修饰，所有是线程安全，相对性能也低一点

StringJoiner像火车拼接车厢一样把字符数组拼接起来

## 枚举类

通过`static final`来定义常量。例如，定义周一到周日这7个常量用7个不同的`int`表示，有一个严重的问题就是，编译器无法检查每个值的合理性

```java
public class Weekday {
    public static final int SUN = 0;
    public static final int MON = 1;
    public static final int TUE = 2;
    public static final int WED = 3;
    public static final int THU = 4;
    public static final int FRI = 5;
    public static final int SAT = 6;
}
```

---

enum定义枚举类

- `enum`常量本身带有类型信息，即`Weekday.SUN`类型是`Weekday`，编译器会自动检查出类型错误
- 不可能引用到非枚举的值，因为无法通过编译
- **`enum`类型的每个常量在JVM中只有一个唯一实例**

enum定义的类与class太大的区别

- 自动继承Enum类，且无法被继承
- **只能定义实例，而无法实例化**
- 可用于Switch语句

```java
public enum Color {
    RED, GREEN, BLUE;
}
	相当于
public final class Color extends Enum { // 继承自Enum，标记为final class
    // 每个实例均为全局唯一:
    public static final Color RED = new Color();
    public static final Color GREEN = new Color();
    public static final Color BLUE = new Color();
    // private构造方法，确保外部无法调用new操作符:
    private Color() {}
}

.name();//返回枚举定义的变量名字

因为枚举类定义的是实例
    enum Weekday {
    	MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);

    	public final int dayValue;

    	private Weekday(int dayValue) {
        	this.dayValue = dayValue;
    	}
	}

这里相当于
    public static final Weekday MON = new Weekday("1");
```

## BigDecimal、BigInteger

完全精准的类，操作时需要使用类中的方法

BigInteger.valueOf或者BigInteger的字符串构造函数

## 工具类

- Math：数学计算
- Random：生成伪随机数
- SecureRandom：生成安全的随机数

## 日期与时间

日期：指某一天，离散的

时间

- 不带日期的时间
- 带日期的时间

---

时刻相同：分别在两个时区的两个人，如果在这一刻通电话，他们各自报出自己手表上的时间，虽然本地时间是不同的，但是这两个时间表示的时刻是相同的。

- 说明每个人的时间都是相同的。因为时区不同转换成的时间也不同

“同一个时刻”在计算机中存储的本质上只是一个整数，我们称它为`Epoch Time`（**时间戳，Java中是long型毫秒**）：==时间只是这个数字的转换形式==

- `Epoch Time`是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数

### 旧API

Date：new对象存储的是当前**带日期的时间**。不能转换时区，很难对日期加减

创建`SimpleDateFormat`并设定目标时区，再格式化date对象

- ```java
  使用long类型的以毫秒表示的时间戳
  public class Date implements Serializable, Cloneable, Comparable<Date> {
  
      private transient long fastTime;
  
      ...
  }
  
  // 获取当前时间:
  Date date = new Date();
  
  .getYear() + 1900;// 必须加上1900
  .getMonth() + 1;// 0~11表示1到12月。必须加上1
  .getDate();
  
  // 转换成字符串、GMT时区、本地时区
  .toString();
  .toGMTString();
  .toLocaleString();
  
  使用SimpleDateFormat对一个Date进行转换
  	yyyy：年
  	MM：月
  	dd: 日
  	HH: 小时
  	mm: 分钟
  	ss: 秒
      
  var sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
  System.out.println(sdf.format(date));
  ```

Calender：比Date多了一个可以做简单的日期和时间运算的功能

- ```java
  // 只有一个获取方式，并且一获取就是当前时间，设置特定的时间只能.clear清除信息，使用set设置对应属性
  Calendar c = Calendar.getInstance();
  
  // 获取信息，年不必加，月份依然要加1，星期1~7表示周日到周六
  .get(int field);
  
  //加5天减2小时
  .add(Calendar.DAY_OF_MONTH, 5);
  .add(Calendar.HOUR_OF_DAY, -2);
  
  // 转换成Date对象以便格式化
  Calendar.getTime();
  ```

TimeZone：时区用`TimeZone`对象表示

- ```java
  // 获取当前时区
  TimeZone.getDefault();
  
  // 获取指定时区。时区的唯一标识是以字符串表示的ID时区
  TimeZone.getTimeZone("GMT+09:00");
  TimeZone.getTimeZone("America/New_York");
  
  TimeZone.getAvailableIDs();
  ```

### 1.8的新api

#### LocalDateTime

LocalDateTime：总是以**当前默认时区返回当前日期与时间**，**默认严格按照ISO 8601规定的日期和时间格式进行打印**

- ISO 8601规定的日期和时间分隔符是`T`。标准格式如下：
  - 日期：yyyy-MM-dd
  - 时间：HH:mm:ss
  - 带毫秒的时间：HH:mm:ss.SSS
  - 日期和时间：yyyy-MM-dd'T'HH:mm:ss
  - 带毫秒的日期和时间：yyyy-MM-dd'T'HH:mm:ss.SSS

- ```java
  LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间
  LocalDate d = dt.toLocalDate(); // 转换到当前日期
  LocalTime t = dt.toLocalTime(); // 转换到当前时间
  
  //将字符串转换为LocalDateTime就可以传入标准格式：
  LocalDateTime dt = LocalDateTime.parse("2019-11-19T15:16:17");
  LocalDate d = LocalDate.parse("2019-11-19");
  LocalTime t = LocalTime.parse("15:16:17");
  
  // 通过静态方法.of创建指定的日期与时间
  
  DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
  dtf.format(LocalDateTime.now())
      
  .plusDays(5).minusHours(3).minusMonths(1);
  
  对日期和时间进行调整则使用withXxx()方法，例如：withHour(15)会把10:11:12变为15:11:12
  ```

---

#### Duration和Period

两个`LocalDateTime`之间的差值使用`Duration`表示，两个`LocalDate`之间的差值用`Period`表示

```java
LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30);
Duration d = Duration.between(start, end);
```

#### ZoneDateTime

`LocalDateTime`总是表示本地日期和时间，要表示一个带时区的日期和时间，就需要`ZonedDateTime`

- 可以简单地把`ZonedDateTime`理解成`LocalDateTime`加`ZoneId`

#### DateTimeFormatter

使用新的`LocalDateTime`或`ZonedLocalDateTime`时，要进行格式化显示，就要使用`DateTimeFormatter`

- 和`SimpleDateFormat`不同的是，`DateTimeFormatter`不但是不变对象，它还是线程安全的

#### Instant

计算机存储的当前时间，本质上只是一个不断递增的整数。

当前时间戳在`java.time`中以`Instant`类型表示，用`Instant.now()`获取当前时间戳，效果和`System.currentTimeMillis()`类似

既然`Instant`就是时间戳，那么，给它附加上一个时区，就可以创建出`ZonedDateTime`

对于某一个时间戳，给它关联上指定的`ZoneId`，就得到了`ZonedDateTime`，继而可以获得了对应时区的`LocalDateTime`

所以，`LocalDateTime`，`ZoneId`，`Instant`，`ZonedDateTime`和`long`都可以互相转换：

```ascii
┌─────────────┐
│LocalDateTime│────┐
└─────────────┘    │    ┌─────────────┐
                   ├───>│ZonedDateTime│
┌─────────────┐    │    └─────────────┘
│   ZoneId    │────┘           ▲
└─────────────┘      ┌─────────┴─────────┐
                     │                   │
                     ▼                   ▼
              ┌─────────────┐     ┌─────────────┐
              │   Instant   │<───>│    long     │
              └─────────────┘     └─────────────┘
```

转换的时候，只需要留意`long`类型以毫秒还是秒为单位即可。

在数据库中存储时间戳时，尽量使用`long`型时间戳，它具有省空间，效率高，不依赖数据库的优点

## 比较

实现Comparable接口重写compareTo方法，可以比较两个对象的大小

当元素没有实现Comparable接口或者说实现的排序方式不适合当前操作，可以选择Comparator接口重写方法作为定制排序规则，传入比如Arrays.sort方法中

# 内部类

创建的引用都是`外部类.内部类`

- 静态内部类：可以通过类名直接访问，属于类的静态属性，可以通过类直接访问，所以`new 外部类.内部类构造函数`
- 成员内部类：是对象的一部分，所以是：`外部实例.new 内部类构造函数`

定义在类里面的类（可以把内部类理解为外部类的一个普通成员）

- 内部类封装性更好，隐藏在一个类之中，同一包中的其他类也不能访问
- `outer.java`里面定义了一个内部类`inner`，一旦编译成功，就会生成两个完全不同的`.class`文件了

静态内部类

```java
静态内部类的可以访问外围类中的所有静态成员，包括private的静态成员。
    
OuterClass.StaticInnerClass staticInnerClass = new OuterClass.StaticInnerClass();
```

成员内部类

```java
成员内部类的对象的创建必须依赖于外围类的对象
	获取外部类对象：OuterClass.this
//先创建外围类对象
OuterClass outer=new OuterClass();

//创建成员内部类对象
OuterClass.InnerClass inner=outer.new InnerClass();
```

局部内部类

```java
局部内部类只能访问final的局部变量
```

匿名内部类

- 匿名内部类用于隐式继承某个类（重写里面的方法或实现抽象方法）或者实现某个接口。

```java
匿名内部类是一个没有给定名字的内部类，在创建这个匿名内部类后，便会立即用来创建并返回此内部类的一个对象引用
```

只专注于具体的实现方法，前提是必须继承或者实现接口。只有一个单抽象方法类的简写，用@FunctionalInterface标记

```java
父类型 引用变量 = new 父类型或者接口类型(){
    				//重写方法
					方法(){
            
        				}
					};
```

# 函数式编程

函数式编程的一个特点就是，允许把函数（方法）本身作为参数传入另一个函数，还允许返回一个函数

函数式编程（Functional Programming）是把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数。

## Lambda

针对单方法接口，即一个接口只定义了一个方法

- 把只定义了单方法的接口称之为`FunctionalInterface`，用注解`@FunctionalInterface`标记。

以匿名内部类编写很繁琐，1.8开始**使用Lambda表达式替换单方法接口。**

```java
//第一种
Runnable runnable = new Runnable() {
	public void run() {
		ystem.out.println("不使用Lambda表达式");
	}
};
runnable.run();
System.out.println("=======================");        

//第二种
Runnable runnable1 = () -> System.out.println("使用Lambda表达式");
runnable1.run();
```

把匿名内部类**只留下重写方法参数和方法体**

```bash
（）->{ }	#这代表了匿名内部类，省略了类定义，参数无需写类型，当方法体内部只有return语句时，return和{}直接可以省略
```

---

有时候，**lambda体可能仅仅调用一个已存在的方法，而不做任何其它事**，对于这种情况，通过一个方法名字来引用这个已存在的方法会更加清晰。

（1）对象引用::实例方法名

（2）类名::静态方法名

（3）类名::实例方法名

（4）类名::new

（5）类型[]::new

## 四大内置函数式接口

四大函数式接口满足了程序设计的大部分情况，**省去了使用Lambda表达式时写函数式接口的步骤。**

`Consumer<T>`：对类型为T的对象进行操作，方法`void accept(T t)`

- ```java
  happy(int money, Consumer<int> con){
      con.accept(money);
  }
  
  happy(1000, (m) -> sout("消费了"+ m +"元"))
      
  Consumer<Person> con1 = (person) -> System.out.println(person.getName());
  		Consumer<Person> con2 = (person) -> System.out.println(person.getAge());
  		Person per = new Person("张三", 20);
  		con1.accept(per);
  		con1.andThen(con2).accept(per);
  		con2.andThen(con1).accept(per);
  ```

`Supplier<T>`：返回类型为T的对象，`T get()`

`Function<T, R>`：对类型为T的对象进行操作，返回类型为R的结果`R apply(T t)`

`Predicate<T>`：`boolean test(T t)`：确定T类型对象是否满足某约束



| 函数式接口 | 抽象方法 | 传入参数类型 | 返回值类型 |
| ---------- | -------- | ------------ | ---------- |
| Consumer   | accept   | T            | void       |
| Supplier   | get      | 无           | T          |
| Function   | apply    | T            | R          |
| Predicate  | test     | T            | boolean    |

## Stream（流）

>主要作用就是对集合数据进行查找过滤等操作，有点类似于SQL的数据库操作

Stream真正把函数式编程的风格引入到了java中。

如果我们要表示一个全体自然数的集合，显然，用`List`是不可能写出来的，因为自然数是无限的，内存再大也没法放到`List`中。但是，用`Stream`可以做到。写法如下：

```java
Stream<BigInteger> naturals = createNaturalStream(); // 全体自然数
```

- 可以“存储”有限个或无限个元素
- 一个`Stream`可以轻易地转换为另一个`Stream`，而不是修改原`Stream`本身。
- 真正的计算通常发生在最后结果的获取，也就是惰性计算。

Stream API的基本用法就是：创建一个`Stream`，然后做若干次转换，最后调用一个求值方法获取真正计算的结果

---

### 创建Stream

```java
1. 通过一个集合创建Stream
	.stream();//顺序流
	.parallelStream();//并行流

2. 通过一个数组创建Stream
    Arrays.stream(arr);

3. 通过Stream.of 
    Stream<Integer> integerStream = Stream.of(1, 2, 3, 5, 6, 7, 8);
	Stream<Student> studentStream = Stream.of(
                new Student(1, "刘备", 18, 90.4),
                new Student(2, "张飞", 19, 87.4),
                new Student(3, "关羽", 21, 67.4));
    }

4. 创建一个无限流
```

### 操作Stream

#### 使用map（根据规则创建新的流）

> `Stream.map()`是`Stream`最常用的一个转换方法，它把一个`Stream`转换为另一个`Stream`。

`map`操作，就是把一种操作运算，映射到一个序列的每一个元素上。例如，对`x`计算它的平方，可以使用函数`f(x) = x * x`

```java
Stream<Integer> s = Stream.of(1, 2, 3, 4, 5);
Stream<Integer> s2 = s.map(n -> n * n);
```

#### 使用filter（根据规则筛选，留下剩下元素的流）

```java
@Test
public void test1(){
	List<Student> list  = StudentData.getStudents();
	//（1）过滤：过滤出所有年龄大于20岁的同学
	list.stream().filter(item->item.getAge()>20).forEach(System.out::println);
	
    //（2）截断流：筛选出前3条数据
	list.stream().limit(3).forEach(System.out::println);
	
    //（3）跳过元素:跳过前5个元素
	list.stream().skip(5).forEach(System.out::println);
	
    //（4）过滤重复数据：
	list.stream().distinct().forEach(System.out::println);
}
```

#### 使用reduce

> 可以把一个`Stream`的所有元素按照聚合函数聚合成一个结果，`reduce()`是聚合方法，聚合方法会立刻对`Stream`进行计算。

```java

```

#### 输出集合

`Stream`通过`collect()`方法可以方便地输出为`List`、`Set`、`Map`，还可以分组输出。

### 常用操作

`Stream`提供的常用操作有：

转换操作：`map()`，`filter()`，`sorted()`，`distinct()`；

合并操作：`concat()`，`flatMap()`；

并行处理：`parallel()`；

聚合操作：`reduce()`，`collect()`，`count()`，`max()`，`min()`，`sum()`，`average()`；

其他操作：`allMatch()`, `anyMatch()`, `forEach()`。

# classpath和jar

classpath：是JVM用到的一个环境变量，它用来指示JVM如何搜索`.class`

- JVM需要知道，如果要加载一个`abc.xyz.Hello`的类，应该去哪搜索对应的`Hello.class`文件。

---

Java定义了一种名字空间，称之为包：`package`。

- 一个类总是属于某个包，类名（比如`Person`）只是一个简写，真正的完整类名是`包名.类名`。
- 通过真正的完整类名可以区分一个类，即使是同名

---

> jar包实际上就是一个zip压缩包，里面包含一个文件夹的完整结构。
>
> jar包可以把`package`组织的目录层级，以及各个目录下的所有文件（包括`.class`文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。

引入一个jar包相当于在当前项目中把jar包中的文件夹完整的复制到了项目中，所以引入了jar包就可以使用别人写的类了。

jar包还可以包含一个特殊的`/META-INF/MANIFEST.MF`文件

- `MANIFEST.MF`是纯文本，可以指定`Main-Class`和其它信息。
- JVM会自动读取这个`MANIFEST.MF`文件，如果存在`Main-Class`，我们就不必在命令行指定启动的类名，而是用更方便的命令：

```
java -jar hello.jar
```

# 异常

> 抛异常，程序会终止。catch块提供处理方式

Throwable

- Error
- Exception（除了RuntimeException，必须捕获或者抛）
  - RuntimeException（10/0要在运行时才知道，所以是运行时异常）
    - `NullPointerException`：对某个`null`的对象调用方法或字段
    - `IndexOutOfBoundsException`：数组索引越界
    - `ArithmeticException`：算术异常
  - 其它

---

抛异常：throw new 异常类

声明异常：方法声明中throws 异常类名

处理异常：

```java
try{
    throw new...;
}catch(Exception e){
    
}finally{
    
}

// 一个逻辑处理两种异常
catch (IOException | NumberFormatException e)

try-catch把一个编译时异常变为一个运行时异常
    
有try-finally、try-catch、try-catch-finally三种组合
```

1. finally里有return，会覆盖其他块的return结果

2. finally里无return时，因为finally是必须要执行的，return要代表整个方法的返回，所以会将try或者catch中的return结果暂时保留

- 如果finally里修改了return相关的值也不起效，因为最后保留的结果会出栈替代
- 如果方法返回值是引用类型，finally的修改会生效，与方法的值传递类似

---

在`catch`中抛出异常，不会影响`finally`的执行。JVM会先执行`finally`，然后抛出异常。

捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！

`finally`抛出异常后，原来在`catch`中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）

- 先用`origin`变量保存原始异常，然后调用`Throwable.addSuppressed()`，把原始异常添加进来，最后在`finally`抛出

---

## Throwable类常用方法

- **`public string getMessage()`**:返回异常发生时的简要描述
- **`public string toString()`**:返回异常发生时的详细信息
- **`public string getLocalizedMessage()`**:返回异常对象的本地化信息。使用 `Throwable` 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage（）`返回的结果相同
- **`public void printStackTrace()`**:在控制台上打印 `Throwable` 对象封装的异常信息

## 自定义异常

在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。

一个常见的做法是自定义一个`BaseException`作为“根异常”，然后，派生出各种业务类型的异常。

`BaseException`需要从一个适合的`Exception`派生，通常建议从`RuntimeException`派生：

```java
public class BaseException extends RuntimeException {
}
```

其他业务类型的异常就可以从`BaseException`派生：

```java
public class UserNotFoundException extends BaseException {
}

public class LoginFailedException extends BaseException {
}

...
```

自定义的`BaseException`应该提供多个构造方法：

```java
public class BaseException extends RuntimeException {
    public BaseException() {
        super();
    }

    public BaseException(String message, Throwable cause) {
        super(message, cause);
    }

    public BaseException(String message) {
        super(message);
    }

    public BaseException(Throwable cause) {
        super(cause);
    }
}
```

上述构造方法实际上都是原样照抄`RuntimeException`。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。

## 空指针异常

如果调用方一定要根据`null`判断，比如返回`null`表示文件不存在，那么考虑返回`Optional<T>`：

```java
public Optional<String> readFromFile(String file) {
    if (!fileExist(file)) {
        return Optional.empty();
    }
    ...
}
```

这样调用方必须通过`Optional.isPresent()`判断是否有结果。

## 断言

```java
public static void main(String[] args) {
    double x = Math.abs(-123.45);
    assert x >= 0;
    System.out.println(x);
}
```

`assert x >= 0;`

即为断言，断言条件`x >= 0`预期为`true`。如果计算结果为`false`，则断言失败，抛出`AssertionError`

- 断言失败时会抛出`AssertionError`，**导致程序结束退出**。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段

- 还可以添加一个可选的断言消息：

  ```java
  assert x >= 0 : "x must >= 0";
  ```

  这样，断言失败的时候，`AssertionError`会带上消息`x must >= 0`，更加便于调试。

==JVM默认关闭断言指令，即遇到`assert`语句就自动忽略了，不执行。==

# 反射

> 程序在运行期可以拿到一个对象的所有信息，保存在Class实例中

JVM在第一次读取到一种`class`类型时，将其加载进内存。

- 每加载一种`class`，JVM就为其创建一个`Class`类型的实例，并关联起来

使用一个类时，如果未加载

1. 加载：将class文件读入内存，并创建对应的Class对象。类加载器就负责加载阶段
2. 链接：将类的二进制数据合并到JRE中
3. 初始化：类的初始化

获得Class对象

1. 直接通过一个`class`的静态变量`class`获取

2. 实例变量提供的`getClass()`方法获取
3. 知道一个`class`的完整类名，可以通过静态方法`Class.forName()`获取

---

Class对象

```java
Class getSuperclass()：获取父类类型；
Class[] getInterfaces()：获取当前类实现的所有接口。
ClassLoader getClassLoader()
    - loadClass加载类，得到一个Class
    
isAssignableFrom()方法可以判断一个向上转型是否可以实现
```

分为

- Filed对象

  ```java
  getField(name);
  getFields();
  
  // 带Declared不包含父类
  getDeclaredField(name);
  getDeclaredFields();
  
  getName();
  getType();
  // 返回字段的修饰符，它是一个int，不同的bit表示不同的含义
  getModifiers();
  
  // 第一个Object参数是指定的实例，第二个Object参数是待修改的值
  set(Object, Object);
  ```

- Method对象

  ```java
  getMethod();
  getMethods();
  getDeclaredMethod();
  getDeclaredMethods();
  
  getName();
  getReturnType();
  getParameterTypes();
  getModifiers();
  
  getAnnotations()
  Object invoke(Object instance, Object... parameters);
  
  setAccessible(true);
  ```

- Constructor对象

  ```java
  getConstructor();
  getConstructors();
  getDeclaredConstructor();
  getDeclaredConstructors();
  
  // 创造实例对象
  newInstance(Object... parameters);
  
  setAccessible(true);
  ```

Java提供的使用反射API读取`Annotation`的方法包括：

判断某个注解是否存在于`Class`、`Field`、`Method`或`Constructor`：

- `Class.isAnnotationPresent(Class)`
- `Field.isAnnotationPresent(Class)`
- `Method.isAnnotationPresent(Class)`
- `Constructor.isAnnotationPresent(Class)`

使用反射API读取Annotation：

- `Class.getAnnotation(Class)`
- `Field.getAnnotation(Class)`
- `Method.getAnnotation(Class)`
- `Constructor.getAnnotation(Class)`

## 动态代理

> 不编写实现类，直接在运行期创建某个`interface`的实例

静态：创建接口-->编写实现类-->创建实例转型为接口调用方法

动态代理

1. 定义一个`InvocationHandler`实例，它负责实现接口的方法调用；

   ```java
   public class Main {
       public static void main(String[] args) {
           InvocationHandler handler = new InvocationHandler() {
               @Override
               public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                   System.out.println(method);
                   if (method.getName().equals("morning")) {
                       System.out.println("Good morning, " + args[0]);
                   }
                   return null;
               }
           };
           Hello hello = (Hello) Proxy.newProxyInstance(
               Hello.class.getClassLoader(), // 传入ClassLoader
               new Class[] { Hello.class }, // 传入要实现的接口
               handler); // 传入处理调用方法的InvocationHandler
           hello.morning("Bob");
       }
   }
   
   interface Hello {
       void morning(String name);
   }
   ```

2. 通过`Proxy.newProxyInstance()`创建`interface`实例

   ```java
   接口类的ClassLoader；
   需要实现的接口数组，至少需要传入一个接口进去；
   用来处理接口方法调用的InvocationHandler实例。
   ```

3. 将返回的Object强转成接口

# 注解

> 放在Java源码的类、方法、字段、参数前的一种特殊“注释”。一种用作标注的“元数据”

框架 = 注解 + 反射 + 设计模式

## Java Doc注解

```java
@author Sanctuary，DtreeL
@version 1.0
@since jdk1.8
@date
    
@param 形参名 形参类型 形参说明
@return 返回值类型 返回值说明
@exception 抛出异常类型 抛出异常说明
```

## 元注解

> 放在其它注解上，用来定义其他注解

### @Target：定义注解能在哪些位置被使用

最常用的元注解是`@Target`。使用`@Target`可以定义`Annotation`能够被应用于源码的哪些位置：

- 类或接口：`ElementType.TYPE`；
- 字段：`ElementType.FIELD`；
- 方法：`ElementType.METHOD`；
- 构造方法：`ElementType.CONSTRUCTOR`；
- 方法参数：`ElementType.PARAMETER`。

### @Retention：定义注解生命周期，默认为`CLASS`

另一个重要的元注解`@Retention`定义了`Annotation`的生命周期：

- 仅编译期：`RetentionPolicy.SOURCE`；
- 仅class文件：`RetentionPolicy.CLASS`；
- 运行期：`RetentionPolicy.RUNTIME`。**不仅在class文件中还加载到内存中**

自定义的`Annotation`都是`RUNTIME`，所以，**务必要加上`@Retention(RetentionPolicy.RUNTIME)`这个元注解**

### @Repeatable：定义一个注解是否可重复使用

使用`@Repeatable`这个元注解可以定义`Annotation`是否可重复。这个注解应用不是特别广泛

### @Inherited：定义子类是否可继承父类定义的注解

`@Inherited`仅针对`@Target(ElementType.TYPE)`类型的`annotation`有效，并且仅针对`class`的继承，对`interface`的继承无效：

```java
@Inherited
@Target(ElementType.TYPE)
public @interface Report {
    int type() default 0;
    String level() default "info";
    String value() default "";
}
```

## 定义注解

`@interface`语法来定义注解（`Annotation`），它的格式如下：

```java
public @interface Report {
    int type() default 0;
    String level() default "info";
    String value() default "";
}
```

注解的参数类似无参数方法，可以用`default`设定一个默认值（强烈推荐）。最常用的参数应当命名为`value`

---

第一步，用`@interface`定义注解：

```java
public @interface Report {
}
```

第二步，添加参数、默认值：

```java
public @interface Report {
    // 类似于方法的返回值类型 方法名定义属性
    int type() default 0;
    String level() default "info";
    String value() default "";
}
```

把最常用的参数定义为`value()`，推荐所有参数都尽量设置默认值。

第三步，用元注解配置注解：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Report {
    int type() default 0;
    String level() default "info";
    String value() default "";
}
```

其中，必须设置`@Target`和`@Retention`，`@Retention`一般设置为`RUNTIME`，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写`@Inherited`和`@Repeatable`。

## 处理注解

> 注解本身对代码逻辑没有任何影响

只有`RUNTIME`类型的注解不但要使用，还经常需要编写。

注解定义后也是一种`class`，所有的注解都继承自`java.lang.annotation.Annotation`，因此，读取注解，需要使用反射API

判断某个注解是否存在于`Class`、`Field`、`Method`或`Constructor`：

- `Class.isAnnotationPresent(Class)`
- `Field.isAnnotationPresent(Class)`
- `Method.isAnnotationPresent(Class)`
- `Constructor.isAnnotationPresent(Class)`

## 使用注解

定义一个`String`字段的规则：字段长度满足`@Range`的参数定义：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Range {
    int min() default 0;
    int max() default 255;
}
```

在某个JavaBean中，我们可以使用该注解：

```java
public class Person {
    @Range(min=1, max=20)
    public String name;

    @Range(max=10)
    public String city;
}
```

但是，定义了注解，本身对程序逻辑没有任何影响。必须自己编写代码来使用注解。这里，我们编写一个`Person`实例的检查方法，它可以检查`Person`实例的`String`字段长度是否满足`@Range`的定义：

```java
void check(Person person) throws IllegalArgumentException, ReflectiveOperationException {
    // 遍历类所有Field:
    for (Field field : person.getClass().getFields()) {
        
        // 获取Field定义的@Range:
        Range range = field.getAnnotation(Range.class);
        
        // 如果@Range存在:
        if (range != null) {
            // 获取Field的值:
            Object value = field.get(person);
            
            // 如果值是String:
            if (value instanceof String) {
                String s = (String) value;
                // 判断值是否满足@Range的min/max:
                if (s.length() < range.min() || s.length() > range.max()) {
                    throw new IllegalArgumentException("Invalid field: " + field.getName());
                }
            }
        }
    }
}
```

这样一来，通过`@Range`注解，配合`check()`方法，就可以完成`Person`实例的检查。注意检查逻辑完全是自己编写的，JVM不会自动给注解添加任何额外的逻辑。

# 泛型

> 把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。一种“代码模板”，可以用一套代码套用各种类型

有了泛型之后
- 代码更加简洁【不用强制转换】
- 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常（误转型）】
- 可读性和稳定性【在编写集合的时候，就限定了类型】
  

泛型接口：确定接口方法的参数类型

---

泛型限制容器的放入和取出类型，限制参数类型

- 对于静态方法，单独改写为“泛型”方法，只需要使用另一个类型即可

## 擦拭法

虚拟机对泛型其实一无所知全部视为Object类型，所有的工作都是编译器做的

- 编译器把类型`<T>`视为`Object`；
- 编译器根据`<T>`自动进行安全的强制转型。

擦拭法决定了泛型`<T>`：

- 不能是基本类型，例如：`int`，Object无法持有基本类型；
- 不能获取带泛型类型的`Class`，例如：`Pair<String>.class`，
  - 对`Pair<String>`和`Pair<Integer>`类型获取`Class`时，获取到的是同一个`Class`，也就是`Pair`类的`Class`；
- 不能判断带泛型类型的类型，例如：`x instanceof Pair<String>`；
- 不能实例化`T`类型，例如：`new T()`。

## 通配符

`<? extends Number> `：继承自Number类型

- 向下转型不确定，所以只能用父类引用读出来不能写

`<? super Integer>`

- 只能写不能读

### PESC

何时使用`extends`，何时使用`super`？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。

即：如果需要返回`T`，它是生产者（Producer），要使用`extends`通配符；如果需要写入`T`，它是消费者（Consumer），要使用`super`通配符。

# 集合

<img src="https://snailclimb.gitee.io/javaguide/docs/java/collection/images/Java-Collections.jpeg" style="zoom:200%;" />

Collection

- List：有序（按照数组索引的顺序进行存储）、可重复
- Set：无序、不可重复

Map：键值对搜索的专家（键无序不可重复、值跟着键无序但是可重复）

## Collection

1. 添加功能

   ```java
   boolean add(Object obj);
   boolean addAll(Collection c);
   ```

2. 删除功能

   ```java
   void clear();
   boolean remove(Object);
   boolean removeAll(Collection c);	//只要集合中一个元素被移除了就返回true
   ```

3. 判断功能

   ```java
   boolean contains(Object o);
   boolean containsAll(Collection c);
   boolean isEmpty();
   ```

4. 获取功能

   ```java
   //Collectio继承Iterable接口得到的方法
   Iterator<E> iterator();
   
   //Iterator也是一个接口只有三个方法，但是没有实现。在实现类中以内部类的方式实现
   boolean hasNext();
   E	next();
   void remove();
   ```

5. 长度功能

   ```java
   int size();
   ```

6. 交集功能

   ```java
   boolean retainAll(Collection c);	//最终结果保留在调用方法的集合中，返回值表示集合是否发生变化
   ```

### List

ArrayList：底层是使用Object[]数组维护存储的对象

- 数组特性：插入删除`O(n-i)`，搜索`O(n)`

LinkedList：底层是使用双向不循环链表维护存储的对象

- 链表特性：插入删除`O(n)`、按索引操作`O(n)`

---

遍历方式

- 底层为数组，for循环-->for each
- 底层为链表，迭代器-->for each

#### ArrayList源码分析

默认容量是10

构造：不指定容量或者指定为0时，构造的是一个空数组。此时第一次进行添加会有扩容操作，所以最好指定为10或者以上

add与扩容

1. size+1与数组长度进行对比，取大值为minCapacity

2. 扩容判断

   - minCapacity大于数组长度时进行扩容，原来容量的基础上扩容0.5倍。当新容量小于minCapacity时直接扩容为minCapacity
   - `elementData = Arrays.copyOf(elementData, newCapacity);`

3. 加入元素修改大小

   ```java
   elementData[size++] = e;
   return true;
   ```

- 涉及到角标的一律先进行角标越界判断
- 对原值做改动的一律返回旧值

- 删除元素时不会减少数组容量`elementData[--size] = null;`，**若希望减少容量则调用trimToSize()**

---

与Vector对比

相同点：都是数组维护

不同点

1. Vector很多操作方法使用synchronized方法修饰，线程安全自然效率低一点
2. Vector初始容量11，扩展容量是原来的一倍

注意

- Vector不推荐使用，线程安全使用JUC包下的CopyOnWriteArrayList

#### LinkedList

- **实现了Deque接口**，可以**操作LinkedList像操作队列和栈一样**
- 有头尾指针

add方法：**往链表最后添加元素**

remove方法：**equals方法**判断是否在集合里面，然后双向链表的删除方法

get/set方法：下标小于长度一半从头遍历，否则从尾遍历

### Set

HashSet：底层HashMap

LinkedSet：底层LinkedHashMap

TreeSet：底层TreeMap

注意点

- Set存储无序唯一对象是利用了Map键无序唯一的特性，其中值使用内部维护的`private static final Object PRESENT = new Object();`进行填充

## Map（数据结构针对键，与值无关）

哈希表：一个数组，特别点在于通过hashCode获得对象所在数组的索引

哈希冲突：哈希值相同时，以该数组索引为链表头或者红黑树根建立链表或者红黑树

注意

- 只有HashMap键允许为null，只有TreeMap和HashMap允许值为null

1. 添加功能

   ```java
   //键是第一次存，直接存储返回null；否则把以前的值替换，返回旧值
   V put(K key, V value);
   ```

2. 删除功能

   ```java
   void clear();
   
   //根据键删除值，返回被删除值
   V remove(Object key);
   ```

3. 判断功能

   ```java
   boolean containsKey(Object key);
   boolean containsValue(Object value);
   boolean isEmpty();
   ```

4. 获取功能

   ```java
   //返回键值对对象的集合
   Set<Map.Entry<K, V>> entrySet();
   
   //所有键集合
   Set<K> keySet();
   
   V get(Object key);
   
   //所有值集合
   Collection<V> values();
   ```

### HashMap

1.8前：数组+链表

1.8：数组+链表+红黑树

- 散列表太满，**需要对散列表再散列，创建一个桶数更多的散列表，并将原有的元素插入到新表中，丢弃原来的表**
- 装填因子(load factor)**决定了何时**对散列表再散列~
  - 装填因子默认为==0.75==，如果表中**超过了75%的位置**已经填入了元素，那么这个表就会用**双倍的桶数**自动进行再散列

1. 参数

   ```java
   //默认初始容量即桶数为16
   static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
   //最大容量2的30次方
   static final int MAXIMUM_CAPACITY = 1 << 30;
   
   //默认装填因子0.75
   static final float DEFAULT_LOAD_FACTOR = 0.75f;
   
   //转换为红黑树哈希表的最小桶数
   static final int MIN_TREEIFY_CAPACITY = 64;
   
   //添加后超过桶里元素超过8转换为红黑树
   static final int TREEIFY_THRESHOLD = 8;
   //取消树化是6
   static final int UNTREEIFY_THRESHOLD = 6;
   
   HashMap内部维护一个Node内部类存储键和值
       Node<K,V>	
       	final int hash;
   		// 键
           final K key;
   		// 值
           V value;
   		
   		// 哈希冲突的下一个结点
           Node<K,V> next;
   
   // 哈希表是结点的数组，默认是null，put时创建
   Node<K,V>[] table;
   ```

2. 构造

   ```java
   // 无参，默认填充因子
   this.loadFactor = DEFAULT_LOAD_FACTOR;
   
   // 指定容量,则取大于容量最近的2次幂作为容量
   ```

3. put

   1. 得到处理后的键hashCode

   2. 判断哈希表是否为空，空则按照默认参数以及指定创建哈希表，不空判断是否需要散列（桶加倍，当大小>容量*填充因子时）

   3. ```bsh
      无哈希冲突，直接放入
          
      有哈希冲突
      	链表：equals判断键，没有则链表尾部插入。
      		插入后树化判断，桶大于64且链表大于8树化，桶小于64则散列
      		
      	红黑树：按照红黑树的情况插入，小于6则链表化
      ```

---

HashTable

- 结构：数组+链表
- 线程安全，性能低
- 初始11,扩容2n+1
- 不要求2次幂容量

实现类：Properties，用于处理属性文件，**key-value都是String类型**

- 放入文件流，直接getXxx，SetXxx获得值

### LinkedHashMap

散列表+双向链表

插入的顺序是有序的(底层链表致使有序)

get方法

```java
调用HashMap定义的方法获取对应的结点，如果是访问顺序的话，把该结点放到链表的最后面
    
最常用的将其放在链表的最后，不常用的放在链表的最前
```

### TreeMap

红黑树，对键进行排序

put方法

红黑树使二叉平衡树，也是二叉搜索树，所以需要比较

```java
V put(K key, V value)
    1. 检查key是否为null
    2. 红黑树为null，新建红黑树
    3. comparator比较，找到合适的位置插入到红黑树中
    4. comparator为null，使用key作为比较器比较，key必须实现Comparable接口
    5. 创建新结点找到父结点位置，调整红黑树使红黑树平衡
```

## 并发集合

| nterface | non-thread-safe         | thread-safe                              |
| :------- | :---------------------- | :--------------------------------------- |
| List     | ArrayList               | CopyOnWriteArrayList                     |
| Map      | HashMap                 | ConcurrentHashMap                        |
| Set      | HashSet / TreeSet       | CopyOnWriteArraySet                      |
| Queue    | ArrayDeque / LinkedList | ArrayBlockingQueue / LinkedBlockingQueue |
| Deque    | ArrayDeque / LinkedList | LinkedBlockingDeque                      |

所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。

---

`Collections`工具类提供了一个旧的线程安全集合转换器，可以这么用：

```java
Map unsafeMap = new HashMap();
Map threadSafeMap = Collections.synchronizedMap(unsafeMap);
```

但是它实际上是用一个包装类包装了非线程安全的`Map`，然后对所有读写方法都用`synchronized`加锁，这样获得的线程安全集合的性能比`java.util.concurrent`集合要低很多，所以不推荐使用。

### ConCurrentHashMap（线程安全）

> 读不加锁。1.7分段数组+链表（分段锁），1.8与HashMap相同（**并发控制使用 synchronized 和 CAS 来操作**，只锁桶）

与Hashtable的不同

- Hashtable是在==**每个方法上都加上了Synchronized**完成同步，效率低下。==
- ConcurrentHashMap通过在==**部分加锁**和**利用CAS算法**来实现同步。==

CAS（比较与交换，Compare and swap） 是一种有名的**无锁算法**

### CopyOnWriteArrayList

> 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。

所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的

### ConCurrentLinkedQueue

阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue

- ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全
- ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景

### BlockingQueue

> 广泛使用在“生产者-消费者”问题中

#### **ArrayBlockingQueue** （非公平、可重入、悲观）

>  一旦创建，容量不能改变。并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作

#### **LinkedBlockingQueue**

通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE

#### **PriorityBlockingQueue**

并发控制采用的是 **ReentrantLock**。只能指定初始的队列大小，后面插入元素的时候，**如果空间不够的话会自动扩容**

### **ConcurrentSkipListMap**

跳表：同时维护了多个链表，并且链表是分层的

- 对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可

![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/32005738.jpg)

## fail-fast

 Java 集合的一种错误检测机制。

**在使用迭代器对集合进行遍历的时候，在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 `ConcurrentModificationException` 异常。 另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。**

- 每当迭代器使用 `hashNext()`/`next()`遍历下一个元素之前，都会检测 `modCount` 变量是否为 `expectedModCount` 值，是的话就返回遍历；否则抛出异常，终止遍历。

## fail-safe

采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 `ConcurrentModificationException` 异常

# IO（装饰者模式）

![](https://note.youdao.com/yws/api/personal/file/346DEFBFB01E4877A064B4923CDC10CD?method=download&shareKey=d890328ca5c6588f2b50501841df940a)

总结

1. 计算机中一切皆字节。无论是图片、视频等都可以用字节表示（代码是在内存中运行的，数据也必须读到内存）
   - 输入输出相对于计算机而言。**输入计算机就是读--使用字节流InputStream；输出计算机就是写--使用字节流OutputStream**
   - 因为字符文本的频繁使用，Write与Reader负责字符的处理，`Reader`和`Writer`本质上是一个能自动编解码的`InputStream`和`OutputStream`。
2. File、Char、Byte、Piped开头是节点流
   - 节点流：直接写入读取某个文件
   - 处理流：对已存在的流的连接和封装，实现更为丰富的流数据处理，处理流的构造方法必需其他的流对象参数。
3. 同步和异步
   - 同步：从Web方面理解，同步的话整个页面都要刷新，所以获取数据呈现是一起的。必须等待数据返回后才能渲染页面呈现。同样的：读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。
   - 异步：前端只发出数据请求，有没有得到数据页面依旧能够渲染呈现。对比异步IO，写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。
4. **字节流有缓冲区时才需要刷新，因为不需要任何转换**

---

## API

### InputStream

| Modifier and Type | Method and Description                                       |
| ----------------- | ------------------------------------------------------------ |
| `int`             | `available()`  返回从该输入流中可以读取（或跳过）的字节数的估计值，而不会被下一次调用此输入流的方法阻塞。 |
| `void`            | `close()`  关闭此输入流并释放与流相关联的任何系统资源。      |
| `void`            | `mark(int readlimit)`  标记此输入流中的当前位置。            |
| `boolean`         | `markSupported()`  测试这个输入流是否支持 `mark`和 `reset`方法。 |
| `abstract int`    | `read()`  从输入流读取数据的下一个字节。                     |
| `int`             | `read(byte[] b)`  从输入流读取一些字节数，并将它们存储到缓冲区 `b` 。 |
| `int`             | `read(byte[] b,  int off, int len)`  从输入流读取最多 `len`字节的数据到一个字节数组。 |
| `void`            | `reset()`  将此流重新定位到上次在此输入流上调用 `mark`方法时的位置。 |
| `long`            | `skip(long n)`  跳过并丢弃来自此输入流的 `n`字节数据。       |

### OutputStream

| Modifier and Type | Method and Description                                       |
| ----------------- | ------------------------------------------------------------ |
| `void`            | `close()`  关闭此输出流并释放与此流相关联的任何系统资源。    |
| `void`            | `flush()`  刷新此输出流并强制任何缓冲的输出字节被写出。      |
| `void`            | `write(byte[] b)`  将 `b.length`字节从指定的字节数组写入此输出流。 |
| `void`            | `write(byte[] b,  int off, int len)`  从指定的字节数组写入 `len`个字节，从偏移 `off`开始输出到此输出流。 |
| `abstract void`   | `write(int b)`  将指定的字节写入此输出流。                   |

### Reader

| Modifier and Type | Method and Description                                       |
| ----------------- | ------------------------------------------------------------ |
| `abstract void`   | `close()`  关闭流并释放与之相关联的任何系统资源。            |
| `void`            | `mark(int readAheadLimit)`  标记流中的当前位置。             |
| `boolean`         | `markSupported()`  告诉这个流是否支持mark（）操作。          |
| `int`             | `read()`  读一个字符                                         |
| `int`             | `read(char[] cbuf)`  将字符读入数组。                        |
| `abstract int`    | `read(char[] cbuf,  int off, int len)`  将字符读入数组的一部分。 |
| `int`             | `read(CharBuffer target)`  尝试将字符读入指定的字符缓冲区。  |
| `boolean`         | `ready()`  告诉这个流是否准备好被读取。                      |
| `void`            | `reset()`  重置流。                                          |
| `long`            | `skip(long n)`  跳过字符                                     |

### Write

| Modifier and Type | Method and Description                                       |
| ----------------- | ------------------------------------------------------------ |
| `Writer`          | `append(char c)`  将指定的字符附加到此作者。                 |
| `Writer`          | `append(CharSequence csq)`  将指定的字符序列附加到此作者。   |
| `Writer`          | `append(CharSequence csq, int start,  int end)`  将指定字符序列的子序列附加到此作者。 |
| `abstract void`   | `close()`  关闭流，先刷新。                                  |
| `abstract void`   | `flush()`  刷新流。                                          |
| `void`            | `write(char[] cbuf)`  写入一个字符数组。                     |
| `abstract void`   | `write(char[] cbuf,  int off, int len)`  写入字符数组的一部分。 |
| `void`            | `write(int c)`  写一个字符                                   |
| `void`            | `write(String str)`  写一个字符串                            |
| `void`            | `write(String str,  int off, int len)`  写一个字符串的一部分。 |

## 使用

### 写入

```java
public static void main(String[] args) {
    Writer fileWrite = null;
	
    // 构建时不指定路径，则在当前项目src文件夹同级处创建文件
    // 如果构建时不指定append参数为true则文件会被清空覆盖，指定为true则在文件后续写
    // windows下换行为\r\n，linux下为\r
    try (Writer writer = fileWrite = new FileWriter("demo.txt",true)) {
        writer.write("圣所");
        writer.flush();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

### 读取

```java
public static void main(String[] args) {
    Reader fileWrite = null;

    // 缓存数组
    char[] buffer = new char[1024];
    StringBuilder stringBuilder = new StringBuilder(32);

    int num = 0;
    // 读取缓存数组得到的返回值是字符个数
    try (Reader reader = fileWrite = new FileReader("demo.txt")) {
        while ((num = reader.read(buffer)) != -1) {
            // 从数组0到读取到的长度，可以读取所有并且避免读取冗余错误（读取到数组满了，下一个读取的字符会从数组0标开始覆盖）
            stringBuilder.append(new String(buffer,0,num));
        }
        System.out.println(stringBuilder.toString());
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

## 缓存流

BufferXxx：使用节点流构建，替代自己创建数组作为缓存区，读写都写在缓存区，使用flush刷新

## 读取键盘录入

System.out（OutputStream）：对应的是标准输出设备，控制台

System.in（InputStream）：对应的标准输入设备，键盘

Scanner对象增强

## 转换流

只有字节流是不需要转换的，所以转换流处于字符流中（字节流转换成字符流）

- InputStreamReader。把字节流转化为字符流
- OutputStreamWrite：把字符流转化为字节流

System.setIn与.setOut可以改变in和out的设备，如改成文件作为输入等

---

`PrintStream`是一种能接收各种数据类型的输出，打印数据时比较方便：

- `System.out`是标准输出；
- `System.err`是标准错误输出。

`PrintWriter`是基于`Writer`的输出。

## File类

> 将文件或文件夹封装成对象，便于对文件或文件夹进行操作

构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径

- Windows平台使用`\`作为路径分隔符，在Java字符串中需要用`\\`表示一个`\`。Linux平台使用`/`作为路径分隔符
- 可以用`.`表示当前目录，`..`表示上级目录

---

- 获取路径／绝对路径／规范路径：`getPath()`/`getAbsolutePath()`/`getCanonicalPath()`；

- 获取目录的文件和子目录：`list()`/`listFiles()`；
- `isDirectory()`，判断该`File`对象是否是一个已存在的目录
- `boolean canRead()`：是否可读；
- `boolean canWrite()`：是否可写；
- `boolean canExecute()`：是否可执行；
- `long length()`：文件字节大小。
- `createNewFile()`创建一个新文件，用`delete()`删除该文件

---

# NIO

nio包下的Path对象是File对象的升级版，与平台无关的一个路径

`Path path = Paths.get("")`

# 序列化

> 序列化是将对象的状态信息转换为可存储或传输的形式的过程。一般是以字节码或XML格式传输。
>
> 而字节码或XML编码格式可以还原为完全相等的对象。这个相反的过程称为反序列化。

序列化：对象-->字节码或者xml；反序列化：字节码或xml-->对象

Java中==通过序列化把对象转换成字节数组==，再通过反序列化把字节数组转换为对象

- 对象序列化保存的是==对象的”状态”，即它的**成员变量**==
- 通过 **ObjectOutputStream** 和 **ObjectInputStream** 对对象进行序列化及反序列化
- 对象输入流和对象输出流

无法序列化static和transient修饰的成员

## Serializable接口

要想对象能够实现序列化和反序列必须`implements Serializable`

在序列化的过程中

- ==优先==调用对象类里的 `writeObject `和`readObject `方法，进行==用户自定义==的序列化和反序列化
- 否则调用是 `ObjectOutputStream `的`defaultWriteObject `方法以及`ObjectInputStream` 的 `defaultReadObject `方法。

writeObject ---> writeObject0 --->writeOrdinaryObject--->writeSerialData--->invokeWriteObject

- writeObject0方法中==会判断要被序列化的类是否是Enum、Array和Serializable类型==，如果不是则直接抛出`NotSerializableException`

## Externalizable接口（需要重写实现方法）

Externalizable继承了Serializable，该接口中定义了两个抽象方法：`writeExternal()`与`readExternal()`

- 需要开发人员重写`writeExternal()`与`readExternal()`方法。
- 使用Externalizable进行序列化的时候，在读取对象时，==会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中==

## SerizlVersionUID（验证版本一致性）

虚拟机是否允许反序列化， 不仅取决于类路径和功能代码是否⼀致， ⼀个⾮常重要的⼀点是两个类的序列化 ID 是否⼀致，不一致抛出异常

一旦类实现了`Serializable`，就建议明确的定义一个`serialVersionUID`。不然在修改类的时候，就会发生异常。

-  一是默认的1L，比如：`private static final long serialVersionUID = 1L`
-  二是借助IDE生成根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段

---

序列化会通过反射调用无参数的构造方法创建一个新的对象。

- ==定义readResolve方法，并在该方法中指定要返回的对象的生成策略，就可以防止单例被破坏==

protobuf：Google出品的性能优异、跨语言、跨平台的序列化库

# 正则表达式

```java
String regex = "20\\d\\d";
"2019".matches(regex); // true
"2100".matches(regex); // false
```

使用正则表达式可以：

- 分割字符串：`String.split()`
- 搜索子串：`Matcher.find()`
- 替换字符串：`String.replaceAll()`

# 多线程

提高CPU利用率

多线程是高并发的基础，能提高系统的并发量和性能

---

一个请求进来，完成该请求需要做多个任务，把任务分别同时执行

## 基本知识

### 线程与进程

> 计算机中一个任务称作一个进程，而一个进程里的多个子任务就称为线程

进程是程序执行的基本单位，程序的一次执行就是进程由创建、运行到终止的一次过程。

线程时比进程更小的基本单位，一个进程可以有多个线程。

区别

- 进程之间相互独立；线程之间共享进程的资源，可能会互相影响

- 线程是轻量级进程，切换的开销小于进程

---

一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行`main()`方法，在`main()`方法内部，又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。

----

多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。

### 并发和并行

并行：单位时间内，多个任务同时执行

并发：同一时间段，多个任务同时执行

### 上下文切换

任务从保存到再加载的一次过程

## 线程相关

### 创建线程

有三种方式

1. 继承Thread类，覆写run方法
2. 实现Runable接口，覆写run方法
3. 实现Callable接口，覆写run方法（与Runable相比，区别在于可以抛异常以及有返回值）

通过start方法启动线程

### 线程的状态

初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态

![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png)

### 中断线程

如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行`run()`方法，使得自身线程能立刻结束运行。

在其他线程中对目标线程调用`interrupt()`方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。

线程间共享变量需要使用`volatile`关键字标记，确保每个线程都能读取到更新后的变量值。

### 守护线程

守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。

因此，JVM退出时，不必关心守护线程是否已结束。

在调用`start()`方法前，调用`setDaemon(true)`把该线程标记为守护线程

### 线程死锁

需要具备四个条件：

1. 互斥条件：一个资源任意一个时刻都只能由一个线程占有
   - 无法破坏该条件
2. 请求和保持条件：一个线程在请求其它资源而阻塞时，持有的资源不会释放
   - 一次性请求所有资源
3. 不剥夺条件：一个线程持有的资源不能被强制剥夺
   - 申请不到时释放自己的资源
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系
   - 按顺序申请、按反序释放

## 线程安全

多个线程（任务）同时读写共享变量，会出现数据不一致的问题。

- 对共享变量进行读写时，必须保证一组指令以原子方式执行，因为Java的内存模型，线程把变量在自己的内存中修改后才刷入主存，所以需要在自己修改时保证修改完毕别的线程才能进行其他操作：即某一个线程执行时，其他线程必须等待：
- 通过加锁和解锁的操作，就能保证多条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。

---

如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）

- 不变类，例如`String`，`Integer`，`LocalDate`，它们的所有成员变量都是`final`，多线程同时访问时只能读不能写
- 类似`Math`这些只提供静态方法，没有成员变量的类，也是线程安全的

### 锁种类

公平锁/非公平锁：顾名思义，多个线程阻塞时，按申请先后顺序获得锁，而非公平锁允许插队

可重入锁：同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

独享锁/共享锁：一次是否只能被一个线程持有

- 互斥锁（ReentrantLock）/读写锁（ReadWriteLock）：独享锁/共享锁的具体实现

乐观锁/悲观锁

- 悲观锁：对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
- 乐观锁：在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

分段锁：先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。

### CAS(Compare and Set)

CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。

- 当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
- CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值

CAS（比较并交换）是CPU指令级的操作，只有一步原子操作，所以非常快。而且CAS避免了请求操作系统来裁定锁的问题，不用麻烦操作系统，直接在CPU内部就搞定了

### synchronized（JVM层面：非公平，悲观，独享，互斥，可重入）

> 保证原子性和可见性

JMM关于synchronized的两条规定：

　　1）线程解锁前，共享变量刷到主存

　　2）线程加锁时，清空工作区的共享变量（类似于清空缓存）

- 注意：加锁与解锁需要是同一把锁

---

#### 对象内存

在 JVM 中，对象在内存中分为三块区域：**对象头**（Header）、实例数据（Instance
Data）和**对齐填充**（Padding）。

对象头：Hotspot虚拟机对象头主要包括两部分数据：

- Mark Word（标记字段）、Klass Pointer（类型指针）；
  - **Mark Word**：默认存储对象的HashCode，分代年龄和锁标志位信息。
  - **Klass Point**：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
- **对象头中保存了锁标志位和指向 monitor 对象的起始地址**
  - 当 Monitor 被某个线程持有后，就会处于锁定状态，如图中的 Owner 部分，会指向持有 Monitor 对象的线程。
  - EntryList和WaitList，主要是用来存放进入及等待获取锁的线程。

![](https://gitee.com/DtreeL/Image-Hosting-Service/raw/master/img/20200516084931.png)

#### 使用方式

修饰方法（ ACC_SYNCHRONIZED 标识--表明是一个同步方法）

- 静态方法：当前类的锁
- 实例方法：当前对象的实例的锁

修饰代码块

- **monitorenter指向同步代码块开始的位置，monitorexit指令指向同步代码块结束的位置**。

  - 当执行 monitorenter 指令时，**线程试图获取锁也就是获取 monitor**(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的。
  - 在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放

  注意

  - 如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

#### 1.6以后的优化

偏向锁-->轻量锁-->自旋锁-->重量级锁（会让其他申请的线程进入阻塞，性能降低）

---

偏向锁：当无线程竞争时消除同步，自动获取锁。降低获取锁的代价。

轻量锁：当无线程竞争时，使用CAS操作（加锁解锁）去替代使用互斥量。其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

自旋锁和自适应锁：

- 互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。

- 轻量锁失败后，**一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的**，为了避免线程再操作系统层面被挂起
- **在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了**

锁消除：检测到那些共享数据不可能存在竞争，那么就执行锁消除

锁粗化：原则上，在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。

#### wait、notify

> 解决synchronized的多线程协调问题

问题：线程在执行`while()`循环时，已经在`getTask()`入口获取了`this`锁，其他线程根本无法调用`addTask()`，因为`addTask()`执行条件也是获取`this`锁

多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。

---

必须在`synchronized`块中才能调用`wait()`方法，因为`wait()`方法调用时，会*释放*线程获得的锁，`wait()`方法返回后，线程又会重新试图获得锁。

- 只能在锁对象上调用`wait()`方法

`notify()`方法，会唤醒一个正在`this`锁等待的线程，从而使得等待线程从`this.wait()`方法返回。

- `notifyAll()`将唤醒所有当前正在`this`锁等待的线程，而`notify()`只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）

### JUC包下的锁（API层面）

ReentrantLock：默认非公平但可实现公平的，悲观，独享，互斥，可重入

- `ReentrantLock`是Java代码实现的锁，就必须先获取锁，然后在`finally`中正确释放锁

- ```java
  .lock;
  .trylock;
  .unlock;
  ```

- 配合Condition对象实现多线程协调

  - 引用的`Condition`对象必须从`Lock`实例的`newCondition()`返回，这样才能获得一个绑定了`Lock`实例的`Condition`实例

  - `await()`、`signal()`、`signalAll()`原理和`synchronized`锁对象的`wait()`、`notify()`、`notifyAll()`是一致的，并且其行为也是一样的

    ```java
    await()会释放当前锁，进入等待状态；
    
    signal():会唤醒某个等待线程；
    
    signalAll():会唤醒所有等待线程；
    
    唤醒线程从await()返回后需要重新获得锁。
    ```

---

ReentrantReadWriteLocK：默认非公平但可实现公平的，悲观，写独享，读共享，读写，可重入

- 只允许一个线程写入，没有写入时可以多个线程读（**读的过程中不允许写，这是一种悲观的读锁**）

- ```java
  // 读锁和写锁
  Lock .readLock;
  Lock .writeLock;
  ```

StampedLock（1.8引入的新读写锁：**不可重入**）：**读的过程中也允许获取写锁后写入**。读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁

- 和`ReadWriteLock`相比，写入的加锁是完全一样的，不同的是读取（把读锁细分为乐观读和悲观读）

  ```java
  tryOptimisticRead()获取一个乐观读锁,返回一个版本号;
  
  通过validate()去验证版本号;
  --在失败的时候，再通过获取悲观读锁再次读取。
  ```

### volatile

当前的 Java 内存模型下，线程可以把变量保存**本地内存**（比如机器的寄存器）中，而不是直接在主存中进行读写。

- 可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成**数据的不一致**。
- 变量声明为**volatile**，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取

防止指令重排序：比如new的时候

### Atomic

> Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。

## 线程池

> 池的作用是：管理和提供更多的功能

创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。

线程池内部维护了若干个线程

- 没有任务的时候，这些线程都处于等待状态。
- 如果有新任务，就分配一个空闲线程执行。
- 如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。

### Executor框架

Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。

主要组成

- 任务（Runable/Callable）
- 任务的执行（Executor）
- 异步计算结果（Future）

`shutdown()`VS`shutdownNow()`

- **`shutdown（）`** :关闭线程池，线程池的状态变为 `SHUTDOWN`。线程池不再接受新任务了，但是队列里的任务得执行完毕。
- **`shutdownNow（）`** :关闭线程池，线程的状态变为 `STOP`。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。

---

`isTerminated()` VS `isShutdown()`

- **`isShutDown`** ：当调用 `shutdown()` 方法后返回为 true。
- **`isTerminated`** ：当调用 `shutdown()` 方法后，并且所有提交的任务完成后返回才为 true

#### 任务（Runable/Callable）

**`Runnable` 接口**或 **`Callable` 接口** 实现类都可以被 **`ThreadPoolExecutor`** 或 **`ScheduledThreadPoolExecutor`** 执行

#### 异步计算结果（Future）

**`Future`** 接口以及 `Future` 接口的实现类 **`FutureTask`** 类都可以代表异步计算的结果。

当我们把 **`Runnable`接口** 或 **`Callable` 接口** 的实现类提交给 **`ThreadPoolExecutor`** 或 **`ScheduledThreadPoolExecutor`** 执行。（调用 `submit()` 方法时会返回一个 **`FutureTask`** 对象）

#### 任务的执行（Executor）

```java
Executor
    |
ExecutorService
    | 实现类
ThreadPoolExecutor
    | 子类
ScheduledThreadPoolExecutor
```

![](https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC01LTMwLzg0ODIzMzMwLmpwZw?x-oss-process=image/format,png)

```java
ExecutorService.execute（Runnable command);

ExecutorService.submit（Runnable task）或 ExecutorService.submit（Callable <T> task）;
submit返回FutureTask对象（实现了Runable）;

主线程
    FutureTask.get()方法来等待任务执行完成。
    FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。
```

### ThreadPoolExecutor

```java
 /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                          int maximumPoolSize,//线程池的最大线程数
                          long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                          TimeUnit unit,//时间单位
                          BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                         ) {
```

**`ThreadPoolExecutor` 3 个最重要的参数：**

- **`corePoolSize` :** 核心线程数线程数定义了最小可以同时运行的线程数量。
- **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，信任就会被存放在队列中。

`ThreadPoolExecutor`其他常见参数:

1. **`keepAliveTime`**:当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；

2. **`unit`** : `keepAliveTime` 参数的时间单位。

3. **`threadFactory`** :executor 创建新线程的时候会用到。

4. **`handler`** :饱和策略。（同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时）

   - **`ThreadPoolExecutor.AbortPolicy`**：抛出 `RejectedExecutionException`异常拒绝新任务的处理。
   - **`ThreadPoolExecutor.CallerRunsPolicy`**：调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
   - **`ThreadPoolExecutor.DiscardPolicy`：** 不处理新任务，直接丢弃掉。
   - **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将丢弃最早的未处理的任务请求。

   Spring 通过 `ThreadPoolTaskExecutor` 或者直接通过 `ThreadPoolExecutor` 的构造函数创建线程池的时候

   - 默认使用的是 `ThreadPoolExecutor.AbortPolicy`，建议使用`ThreadPoolExecutor.CallerRunsPolicy`。当最大池被填满时，此策略为我们提供可伸缩队列。

   

![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB.jpg)

**线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险**

Executors 返回线程池对象的弊端如下：

- **`FixedThreadPool` 和 `SingleThreadExecutor`** ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。
- **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。

### 线程池原理

**`execute`方法**

![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png)

### 其他线程池

`FixedThreadPool` 被称为可重用固定线程数的线程池

- **新创建的 `FixedThreadPool` 的 `corePoolSize` 和 `maximumPoolSize` 都被设置为 nThreads，这个 nThreads 参数是我们使用的时候自己传递的**
- **使用无界队列 `LinkedBlockingQueue`（队列的容量为 Intger.MAX_VALUE）作为线程池的工作队列**

---

`SingleThreadExecutor` 是只有一个线程的线程池

- 使用无界队列 `LinkedBlockingQueue` 作为线程池的工作队列（队列的容量为 Intger.MAX_VALUE）

---

`CachedThreadPool` 是一个会根据需要创建新线程的线程池

- `CachedThreadPool` 的`corePoolSize` 被设置为空（0），`maximumPoolSize`被设置为 Integer.MAX.VALUE，即它是无界的
- 这也就意味着如果主线程提交任务的速度高于 `maximumPool` 中线程处理任务的速度时，`CachedThreadPool` 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。

---

**`ScheduledThreadPoolExecutor` 主要用来在给定的延迟后运行任务，或者定期执行任务。**

- 使用的任务队列 `DelayQueue` 封装了一个 `PriorityQueue`。

- **`PriorityQueue` 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(`ScheduledFutureTask` 的 `time` 变量小的先执行)，**
  - **如果执行所需时间相同则先提交的任务将被先执行(`ScheduledFutureTask` 的 `squenceNumber` 变量小的先执行)。**

### 线程池大小确定

有一个简单并且适用面比较广的公式：

- **CPU 密集型任务(N+1)：** 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
- **I/O 密集型任务(2N)：** 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

**如何判断是 CPU 密集任务还是 IO 密集任务？**

CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。

- 单凡涉及到网络读取，文件读取这类都是 IO 密集型
- 这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。

## ThreadLocal

Web应用程序就是典型的多任务应用，每个用户请求页面时，都会创建一个任务，然后通过线程池去执行这些任务。

在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。

---

Java标准库提供了一个特殊的`ThreadLocal`，它可以在一个线程中传递同一个对象。

`ThreadLocal`实例通常总是以静态字段初始化如下：

```java
static ThreadLocal<User> threadLocalUser = new ThreadLocal<>();
```

通过设置一个`User`实例关联到`ThreadLocal`中，在移除之前，所有方法都可以随时获取到该`User`实例

---

**实际上，可以把`ThreadLocal`看成一个全局`Map<Thread, Object>`：每个线程获取`ThreadLocal`变量时，总是使用`Thread`自身作为key：**

```java
Object threadLocalValue = threadLocalMap.get(Thread.currentThread());
```

因此，`ThreadLocal`相当于给每个线程都开辟了一个独立的存储空间，各个线程的`ThreadLocal`关联的实例互不干扰。

最后，特别注意`ThreadLocal`一定要在`finally`中清除

- 因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果`ThreadLocal`没有被清除，该线程执行其他代码时，会把上一次的状态带进去。

## AQS（AbstractQueuedSynchronizer）

> 用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器。使用了**模板方法模式**

### 原理

**AQS核心思想是**

- **如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。**
- **如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**

CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。

![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/AQS%E5%8E%9F%E7%90%86%E5%9B%BE.png)

AQS使用一个int成员变量来表示同步状态，

- 通过内置的FIFO队列来完成获取资源线程的排队工作。

- 使用CAS对该同步状态进行原子操作实现对其值的修改。
- 状态信息通过protected类型的getState，setState，compareAndSetState进行操作

### 资源共享方式

Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：

- 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
- 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的

**Share**（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。

### 组件总结

- **Semaphore(信号量)-允许多个线程同时访问：** synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。
- **CountDownLatch （倒计时器）：** CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。
- **CyclicBarrier(循环栅栏)：** CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。
  - 主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。
  - 它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。

# 网络编程

> IP：定位网络上的一台计算机或者设备
>
> ​		分类方式：IPV4（4个字节，4个无符号整数），IPV6（16个字节，8个无符号整数）
>
> ​					       公网（万维网），私网（局域网，192.168.开头）
>
> port：定位机器上的应用程序
>
> MAC：网卡上的独一无二的值，代表一台具体的设备

IP：InetAddress类

TCP：IP+端口：Socket类（客户端），ServerSocket（服务端），获得流来发送/接收

- ServerSocket（服务端） .accpet获得客户端的Socket，然后获得流

UDP：DatagramSocket类，DatagramPacket类

# JDBC（Java Database Connectivity）

> Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。

访问某个具体的数据库，我们只需要引入该厂商提供的JDBC驱动，就可以通过JDBC接口来访问

- 我们把某个数据库实现了JDBC接口的jar包称为JDBC驱动。

查询需要得到数据，所以有ResultSet对象

更新不需要，所以直接是关闭资源

## Connection

Connection代表一个JDBC连接，它相当于Java程序到数据库的连接（通常是TCP连接）。

- 打开一个Connection时，需要准备URL、用户名和口令，才能成功连接到数据库。

```java
// 获取连接，如果有连接池，就是从连接池中获得Connection，连接池里拥有连接的相关信息
Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)
```

```java
try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
    try (PreparedStatement ps = conn.prepareStatement("SELECT id, grade, name, gender FROM students WHERE gender=? AND grade=?")) {
        ps.setObject(1, "M"); // 注意：索引从1开始
        ps.setObject(2, 3);
        try (ResultSet rs = ps.executeQuery()) {
            while (rs.next()) {
                long id = rs.getLong("id");
                long grade = rs.getLong("grade");
                String name = rs.getString("name");
                String gender = rs.getString("gender");
            }
        }
    }
}
```

| SQL数据类型   | Java数据类型             |
| :------------ | :----------------------- |
| BIT, BOOL     | boolean                  |
| INTEGER       | int                      |
| BIGINT        | long                     |
| REAL          | float                    |
| FLOAT, DOUBLE | double                   |
| CHAR, VARCHAR | String                   |
| DECIMAL       | BigDecimal               |
| DATE          | java.sql.Date, LocalDate |
| TIME          | java.sql.Time, LocalTime |

## JDBC Batch

SQL数据库对SQL语句相同，但只有参数不同的若干语句可以作为batch执行，即批量执行，这种操作有特别优化，速度远远快于循环执行每个SQL。

- 需要对同一个`PreparedStatement`反复设置参数并调用`addBatch()`，这样就相当于给一个SQL加上了多组参数，相当于变成了“多行”SQL。
- 调用的不是`executeUpdate()`，而是`executeBatch()`，因为我们设置了多组参数，相应地，返回结果也是多个`int`值，因此返回类型是`int[]`，循环`int[]`数组即可获取每组参数执行后影响的结果数量。

## JDBC连接池

为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。

- JDBC连接池有一个标准的接口`javax.sql.DataSource`

常用的JDBC连接池有：

- HikariCP
- C3P0
- BoneCP
- Druid

目前使用最广泛的是HikariCP。

---

语法不同：PreparedStatement可以使用预编译的sql，而Statment只能使用静态的sql

效率不同：PreparedStatement可以使用sql缓存区，效率比Statment高

安全性不同：PreparedStatement可以有效防止sql注入，而Statment不能防止sql注入。

## DBUtils

简化增删改操作

# 单元测试

> Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。

使用`main()`方法测试有很多缺点：

一是只能有一个`main()`方法，不能把测试代码分离，

二是没有打印出测试结果和期望结果，例如，`expected: 3628800, but actual: 123456`，

三是很难编写一组通用的测试代码。

## JUnit

一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。

- 编写Test结尾的对应测试类

```java
// 导入Assertion类静态方法
import static org.junit.jupiter.api.Assertions.*;

public class FactorialTest {

    @Test
    void testFact() {
        // 期望Factorial.fact(1)返回1
        assertEquals(1, Factorial.fact(1));
        assertEquals(2, Factorial.fact(2));
        assertEquals(6, Factorial.fact(3));
        assertEquals(3628800, Factorial.fact(10));
        assertEquals(2432902008176640000L, Factorial.fact(20));
    }
}

// 浮点数无法精确地进行比较，因此，我们需要调用指定一个误差值
assertEquals(double expected, double actual, double delta);
```

### Fixture

JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。

- 编写Fixture是指针对每个`@Test`方法，编写`@BeforeEach`方法用于初始化测试资源，编写`@AfterEach`用于清理测试资源；
- 必要时，可以编写`@BeforeAll`和`@AfterAll`，使用静态变量来初始化耗时的资源，并且在所有`@Test`方法的运行前后仅执行一次。

```java
 Calculator calculator;

    @BeforeEach
    public void setUp() {
        this.calculator = new Calculator();
    }

    @AfterEach
    public void tearDown() {
        this.calculator = null;
    }

// @BeforeAll和@AfterAll在所有@Test方法运行前后仅运行一次，因此，它们只能初始化静态变量
public class DatabaseTest {
    static Database db;

    @BeforeAll
    public static void initDatabase() {
        db = createDb(...);
    }
    
    @AfterAll
    public static void dropDatabase() {
        ...
    }
}
```

### 异常测试

```java
@Test
void testNegative() {
    assertThrows(IllegalArgumentException.class, new Executable() {
        @Override
        public void execute() throws Throwable {
            Factorial.fact(-1);
        }
    });
}
```

`assertThrows()`来期望捕获一个指定的异常。第二个参数`Executable`封装了我们要执行的会产生异常的代码

`assertThrows()`在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。

### 条件测试

排出某些`@Test`方法，不要让它运行，这时，我们就可以给它标记一个`@Disabled`

### 参数测试

如果待测试的输入和输出是一组数据： 可以把测试数据组织起来用不同的测试数据调用相同的测试方法

