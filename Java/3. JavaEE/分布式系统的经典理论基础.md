# 分布式系统的经典理论基础

## 设计理念

分布式系统架构的第一原则是不要分布

目标：提升系统的整体性能和吞吐量另外还要尽量保证分布式系统的容错性

- 即使采用了分布式，也要提升单机的性能

## 设计思路

中心化：大体上分为两种角色： **“领导”** 和 **“干活的”**

- “领导”通常负责分发任务并监督“干活的”，谁都不能偷懒，闲了就分配任务，挂了就踢走
- 问题在于领导挂了群龙无首或者领导的能力不强

去中心化：众生平等

- **不是不要中心，而是由节点来自由选择中心**，自发的举行“会议”选举新的“领导”主持工作
- 问题在于一个集群由于网络的故障，被分为至少两个彼此无法通信的单独集群，此时如果两个集群都各自工作，则可能会产生严重的数据冲突和错误。

## 分布式与集群的区别

- **分布式：** 一个业务分拆多个子业务，部署在不同的服务器上
- **集群：** 同一个业务，部署在多个服务器上。比如之前做电商网站搭的redis集群以及solr集群都是属于将redis服务器提供的缓存服务以及solr服务器提供的搜索服务部署在多个服务器上以提高系统性能、并发量解决海量存储问题。

## CAP原理

对于一个分布式计算系统来说，不可能同时满足以下三点：

- 一致性（Consistence） :所有节点访问同一份最新的数据副本
- 可用性（Availability）:每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据
- 分区容错性（Partition tolerance） : 分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

**决定了P之后才有C和A的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。**

## BASE理论

**BASE** 是 **Basically Available（基本可用）** 、**Soft-state（软状态）** 和 **Eventually Consistent（最终一致性）** 三个短语的缩写。

- 基于CAP定理逐步演化而来的，它大大降低了我们对系统的要求。

---

牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。

当前主要有以下两种做法：

- 按功能划分数据库
- 分片（如开源的Mycat、Amoeba等）。

# 分布式事务

就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。

本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

## 产生的原因

分库分表：如果一个操作既访问01库，又访问02库，而且要保证数据的一致性，那么就要用到分布式事务。

应用SOA化：业务的服务化。

- 单机支撑了整个电商网站，现在对整个网站进行拆解，分离出了订单中心、用户中心、库存中心。
- 对于订单中心，有专门的数据库存储订单信息，用户中心也有专门的数据库存储用户信息，库存中心也会有专门的数据库存储库存信息。
- 这时候如果要同时对订单和库存进行操作，那么就会涉及到订单数据库和库存数据库，为了保证数据一致性，就需要用到分布式事务。

## 解决方法

### 基于XA协议的两阶段提交

XA是一个分布式事务协议

XA中大致分为两部分：事务管理器和本地资源管理器。

- 其中本地资源管理器往往由数据库实现
- 事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。

XA无法满足高并发场景

### 消息事务+最终一致性