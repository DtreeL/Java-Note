# 本地缓存解决方案

**一：JDK 自带的 `HashMap` 和 `ConcurrentHashMap`了。**

- 一个稍微完善一点的缓存框架至少要提供：过期时间、淘汰机制、命中率统计这三点。
- 而JDK自带只提供缓存

**二：`Ehcache` 、 `Guava Cache` 、`Spring Cache`这三者是使用的比较多的本地缓存框架。**

- 使用 `Spring Cache` 的注解实现缓存的话，代码会看着很干净和优雅，但是很容易出现问题比如缓存穿透、内存溢出。

**三 ：`Caffeine`**

- 相比于 `Guava`来说 `Caffeine` 在各个方面比如性能要更加优秀，一般建议使用其来替代 `Guava`。并且， `Guava` 和 `Caffeine` 的使用方式很像！

本地缓存固然好，但是缺陷也很明显，比如多个相同服务之间的本地缓存的数据无法共享。

# 分布式缓存

同一个相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的，因为本地缓存只在当前机器上有。

使用分布式缓存之后，缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。

分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用的信息。

# Redis介绍

Redis 就是一个 C 语言开发的数据库，不过与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。

- 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。

# 缓存处理流程

1. 如果用户请求的数据在缓存中就直接返回。
2. 缓存中不存在的话就看数据库中是否存在。
3. 数据库中存在的话就更新缓存中的数据。
4. 数据库中不存在的话就返回空数据。

要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！

# Redis线程模型

Redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

- 多个 socket
- IO 多路复用程序
- 文件事件分派器
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

# Redis常用数据结构及使用场景

String（key-value）

- **常用命令:** set,get,decr,incr,mget 等。
- value 其实不仅可以是 String，也可以是数字
- 常规 key-value 缓存应用； 常规计数：微博数，粉丝数等。

Hash

- **常用命令：** hget,hset,hgetall 等。

- hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象
- 可以 hash 数据结构来存储用户信息，商品信息等等。

List

- **常用命令:** lpush,rpush,lpop,rpop,lrange 等
- Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。
- 微博的关注列表，粉丝列表，消息列表等功能

Set

- **常用命令：** sadd,spop,smembers,sunion 等
- 存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择
- 共同关注、共同粉丝、共同喜好等功能

Sorted Set

- **常用命令：** zadd,zrange,zrem,zcard 等
- 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列。
- 直播间在线用户列表，各种礼物排行榜

# Redis设置过期时间

set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。

删除方式

- **定期删除**：Redis 默认是每隔 100ms 就**随机抽取**一些设置了过期时间的 key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 Redis 存了几十万个 key ，每隔 100ms 就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
- **惰性删除** ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去**查一下那个 key，才会被 Redis 给删除掉**。这就是所谓的惰性删除，也是够懒的哈！

# Redis淘汰机制

如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存块耗尽了。怎么解决这个问题呢？ **Redis 内存淘汰机制。**

**Redis 提供 6 种数据淘汰策略：**

1. **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中**挑选最近最少使用**的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑**选将要过期**的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中**任意选择数据淘汰**
4. **allkeys-lru**：当**内存不足**以容纳新写入数据时，在键空间中，**移除最近最少使用的 key**（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0 版本后增加以下两种：

1. **volatile-lfu**：从已设置过期时间的数据集(server.db[i].expires)中挑选**最不经常使用**的数据淘汰
2. **allkeys-lfu**：当**内存不足**以容纳新写入数据时，在键空间中，**移除最不经常**使用的 key

# Redis持久化机制

**快照（snapshotting）持久化（RDB）**（默认）

**AOF（append-only file）持久化**

- AOF 持久化 的实时性更好，因此已成为主流的持久化方案
- 每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件

# Redis事务

 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能

事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。

Redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。

# 缓存穿透

大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。

1. 做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端

2. **缓存无效 key**：缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间
3. **布隆过滤器**：非常方便地判断一个给定数据是否存在于海量数据中
   - **布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

**当一个元素加入布隆过滤器中的时候，会进行哪些操作：**

1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。

**当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：**

1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

# 缓存雪崩

**缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求**

Redis服务不可用：

1. 采用Redis集群，避免单机出现问题整个缓存服务都没办法使用。
2. 限流，避免同时处理大量的请求。

热点缓存失效：

1. 设置不同的失效时间比如随机设置缓存的失效时间。
2. 缓存永不失效。

# Redis并发竞争Key问题

多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！

分布式锁（zookeeper 和 Redis 都可以实现分布式锁）来解决

# 缓存与数据库双写时数据的一致性

> 只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题

读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况

串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。